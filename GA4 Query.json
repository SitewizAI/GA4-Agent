{"description":"Runs a query using bigquery and outputs as text","icon_bg_color":null,"updated_at":"2024-09-06T21:26:12+00:00","webhook":false,"id":"2dcae365-b265-4084-b9bd-a3d9bcc100c7","name":"GA4 Query","icon":null,"is_component":true,"endpoint_name":null,"data":{"edges":[],"nodes":[{"data":{"id":"GroupNode-zAmwl","type":"GroupNode","node":{"display_name":"GA4 Query","documentation":"","description":"Runs a query using bigquery and outputs as text","template":{"query_params_APIRequest-8jnhp":{"trace_as_input":true,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"value":"","name":"query_params","display_name":"Query Parameters","advanced":false,"input_types":["Data"],"dynamic":false,"info":"The query parameters to append to the URL.","title_case":false,"type":"other","_input_type":"DataInput","proxy":{"id":"APIRequest-PVjtY","field":"query_params"}},"code_APIRequest-8jnhp":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import asyncio\nimport json\nfrom typing import Any, List, Optional\nfrom urllib.parse import parse_qsl, urlencode, urlparse, urlunparse\n\nimport httpx\nfrom loguru import logger\n\nfrom langflow.base.curl.parse import parse_context\nfrom langflow.custom import Component\nfrom langflow.io import DataInput, DropdownInput, IntInput, MessageTextInput, NestedDictInput, Output\nfrom langflow.schema import Data\nfrom langflow.schema.dotdict import dotdict\n\n\nclass APIRequestComponent(Component):\n    display_name = \"API Request\"\n    description = (\n        \"This component allows you to make HTTP requests to one or more URLs. \"\n        \"You can provide headers and body as either dictionaries or Data objects. \"\n        \"Additionally, you can append query parameters to the URLs.\\n\\n\"\n        \"**Note:** Check advanced options for more settings.\"\n    )\n    icon = \"Globe\"\n    name = \"APIRequest\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"urls\",\n            display_name=\"URLs\",\n            is_list=True,\n            info=\"Enter one or more URLs, separated by commas.\",\n        ),\n        MessageTextInput(\n            name=\"curl\",\n            display_name=\"Curl\",\n            info=\"Paste a curl command to populate the fields. This will fill in the dictionary fields for headers and body.\",\n            advanced=False,\n            refresh_button=True,\n        ),\n        DropdownInput(\n            name=\"method\",\n            display_name=\"Method\",\n            options=[\"GET\", \"POST\", \"PATCH\", \"PUT\"],\n            value=\"GET\",\n            info=\"The HTTP method to use (GET, POST, PATCH, PUT).\",\n        ),\n        NestedDictInput(\n            name=\"headers\",\n            display_name=\"Headers\",\n            info=\"The headers to send with the request as a dictionary. This is populated when using the CURL field.\",\n            input_types=[\"Data\"],\n        ),\n        NestedDictInput(\n            name=\"body\",\n            display_name=\"Body\",\n            info=\"The body to send with the request as a dictionary (for POST, PATCH, PUT). This is populated when using the CURL field.\",\n            input_types=[\"Data\"],\n        ),\n        DataInput(\n            name=\"query_params\",\n            display_name=\"Query Parameters\",\n            info=\"The query parameters to append to the URL.\",\n        ),\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Timeout\",\n            value=5,\n            info=\"The timeout to use for the request.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"make_requests\"),\n    ]\n\n    def parse_curl(self, curl: str, build_config: dotdict) -> dotdict:\n        try:\n            parsed = parse_context(curl)\n            build_config[\"urls\"][\"value\"] = [parsed.url]\n            build_config[\"method\"][\"value\"] = parsed.method.upper()\n            build_config[\"headers\"][\"value\"] = dict(parsed.headers)\n\n            if parsed.data:\n                try:\n                    json_data = json.loads(parsed.data)\n                    build_config[\"body\"][\"value\"] = json_data\n                except json.JSONDecodeError as e:\n                    logger.error(f\"Error decoding JSON data: {e}\")\n            else:\n                build_config[\"body\"][\"value\"] = {}\n        except Exception as exc:\n            logger.error(f\"Error parsing curl: {exc}\")\n            raise ValueError(f\"Error parsing curl: {exc}\")\n        return build_config\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name == \"curl\" and field_value:\n            build_config = self.parse_curl(field_value, build_config)\n        return build_config\n\n    async def make_request(\n        self,\n        client: httpx.AsyncClient,\n        method: str,\n        url: str,\n        headers: Optional[dict] = None,\n        body: Optional[dict] = None,\n        timeout: int = 5,\n    ) -> Data:\n        method = method.upper()\n        if method not in [\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\"]:\n            raise ValueError(f\"Unsupported method: {method}\")\n\n        if isinstance(body, str) and body:\n            try:\n                body = json.loads(body)\n            except Exception as e:\n                logger.error(f\"Error decoding JSON data: {e}\")\n                body = None\n                raise ValueError(f\"Error decoding JSON data: {e}\")\n\n        data = body if body else None\n\n        try:\n            response = await client.request(method, url, headers=headers, json=data, timeout=timeout)\n            try:\n                result = response.json()\n            except Exception:\n                result = response.text\n            return Data(\n                data={\n                    \"source\": url,\n                    \"headers\": headers,\n                    \"status_code\": response.status_code,\n                    \"result\": result,\n                },\n            )\n        except httpx.TimeoutException:\n            return Data(\n                data={\n                    \"source\": url,\n                    \"headers\": headers,\n                    \"status_code\": 408,\n                    \"error\": \"Request timed out\",\n                },\n            )\n        except Exception as exc:\n            return Data(\n                data={\n                    \"source\": url,\n                    \"headers\": headers,\n                    \"status_code\": 500,\n                    \"error\": str(exc),\n                },\n            )\n\n    def add_query_params(self, url: str, params: dict) -> str:\n        url_parts = list(urlparse(url))\n        query = dict(parse_qsl(url_parts[4]))\n        query.update(params)\n        url_parts[4] = urlencode(query)\n        return urlunparse(url_parts)\n\n    async def make_requests(self) -> List[Data]:\n        method = self.method\n        urls = [url.strip() for url in self.urls if url.strip()]\n        curl = self.curl\n        headers = self.headers or {}\n        body = self.body or {}\n        timeout = self.timeout\n        query_params = self.query_params.data if self.query_params else {}\n\n        if curl:\n            self._build_config = self.parse_curl(curl, dotdict())\n\n        if isinstance(headers, Data):\n            headers = headers.data\n\n        if isinstance(body, Data):\n            body = body.data\n\n        bodies = [body] * len(urls)\n\n        urls = [self.add_query_params(url, query_params) for url in urls]\n\n        async with httpx.AsyncClient() as client:\n            results = await asyncio.gather(\n                *[self.make_request(client, method, u, headers, rec, timeout) for u, rec in zip(urls, bodies)]\n            )\n        self.status = results\n        return results\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false,"display_name":"code","proxy":{"id":"APIRequest-PVjtY","field":"code"}},"curl_APIRequest-8jnhp":{"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"value":"","name":"curl","display_name":"Curl","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Paste a curl command to populate the fields. This will fill in the dictionary fields for headers and body.","refresh_button":true,"title_case":false,"type":"str","_input_type":"MessageTextInput","proxy":{"id":"APIRequest-PVjtY","field":"curl"}},"method_APIRequest-8jnhp":{"trace_as_metadata":true,"options":["GET","POST","PATCH","PUT"],"combobox":false,"required":false,"placeholder":"","show":true,"value":"POST","name":"method","display_name":"Method","advanced":true,"dynamic":false,"info":"The HTTP method to use (GET, POST, PATCH, PUT).","title_case":false,"type":"str","_input_type":"DropdownInput","proxy":{"id":"APIRequest-PVjtY","field":"method"}},"timeout_APIRequest-8jnhp":{"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"value":"5","name":"timeout","display_name":"Timeout","advanced":true,"dynamic":false,"info":"The timeout to use for the request.","title_case":false,"type":"int","_input_type":"IntInput","proxy":{"id":"APIRequest-PVjtY","field":"timeout"}},"urls_APIRequest-8jnhp":{"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":true,"required":false,"placeholder":"","show":true,"value":["https://bigquery.googleapis.com/bigquery/v2/projects/spherical-proxy-424916-c9/queries"],"name":"urls","display_name":"URLs","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Enter one or more URLs, separated by commas.","title_case":false,"type":"str","_input_type":"MessageTextInput","proxy":{"id":"APIRequest-PVjtY","field":"urls"}},"code_CustomComponent-lrBZe":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"# from langflow.field_typing import Data\nfrom langflow.custom import Component\nfrom langflow.io import MessageTextInput, Output\nfrom langflow.schema import Data\nimport re  # Import regex module\n\nclass CustomComponent(Component):\n    display_name = \"Format Body\"\n    description = \"Turn OpenAI SQL output into a body to send with a fetch.\"\n    documentation: str = \"http://docs.langflow.org/components/custom\"\n    icon = \"custom_components\"\n    name = \"CustomComponent\"\n\n    inputs = [\n        MessageTextInput(name=\"input_value\", display_name=\"Input Value\", value=\"```sql\\nbigquery-public-data.ga4_obfuscated_sample_ecommerce.events_*\\n```\"),\n    ]\n\n    outputs = [\n        Output(display_name=\"Output\", name=\"output\", method=\"build_output\"),\n    ]\n\n    def build_output(self) -> Data:\n        # Remove the surrounding markdown and any trailing newline\n        input_value_cleaned = re.sub(r\"^```sql\\n|```$\", \"\", self.input_value.strip()).strip()\n\n        # Format the cleaned SQL string into the desired object\n        formatted_data = {\n            \"query\": input_value_cleaned,\n            \"maxResults\": 20,\n            \"timeoutMs\": 10000,\n            \"useLegacySql\": False\n        }\n        \n        # Return the formatted data as the output\n        data = Data(value=formatted_data)\n        self.status = data\n        \n        # Print the formatted data to the chat (for debugging purposes)\n        print(f\"Output Data: {formatted_data}\")\n        \n        return formatted_data\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false,"display_name":"code","proxy":{"id":"CustomComponent-AybY7","field":"code"}},"input_value_CustomComponent-lrBZe":{"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"input_value","value":"","display_name":"Input Value","advanced":false,"input_types":["Message"],"dynamic":false,"info":"","title_case":false,"type":"str","_input_type":"MessageTextInput","proxy":{"id":"CustomComponent-AybY7","field":"input_value"}},"code_FetchProcessorComponent-p3ylx":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from langflow.custom import Component\nfrom langflow.io import MessageTextInput, Output\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\nimport json\n\n\nclass FetchProcessorComponent(Component):\n    display_name = \"Fetch Processor\"\n    description = \"Process fetch output, print it, and stringify it for chat.\"\n    documentation: str = \"http://docs.langflow.org/components/custom\"\n    icon = \"custom_components\"\n    name = \"FetchProcessorComponent\"\n\n    inputs = [\n        HandleInput(\n            name=\"fetch_response\",\n            display_name=\"Fetch Response\",\n            input_types=[\"Data\"],\n        )\n    ]\n\n    outputs = [\n        Output(display_name=\"Processed Output\", name=\"processed_output\", method=\"process_output\"),\n    ]\n    \n    def process_output(self) -> Message:\n        try:\n            # Directly use the fetch_response as the input data\n            response_data = self.fetch_response\n\n            # Extract the response content\n            content = str(response_data[0].data[\"result\"])\n            \n            # Truncate the content to a specific length (e.g., 5000 characters)\n            max_length = 5000\n            truncated_content = content[:max_length]\n            \n            # Convert the truncated content to a string that can be printed\n            output_str = \"Processed Output: \" + str(truncated_content)+\"...\"\n            \n            \n            # Return the processed string as a Message\n            self.status = output_str\n            return Message(text=output_str)\n\n        except Exception as e:\n            # Handle any errors and print them\n            error_message = f\"Error processing fetch response: {str(e)}\"\n            print(error_message)\n            return Message(text=error_message)\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false,"display_name":"code","proxy":{"id":"FetchProcessorComponent-cAiH1","field":"code"}},"code_CreateHeaders-JXbj1":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from langflow.custom import Component\nfrom langflow.inputs import MessageTextInput\nfrom langflow.template import Output\nfrom pydantic.v1 import SecretStr\nfrom langflow.schema import Data\n\n\n\nclass CreateHeadersComponent(Component):\n    display_name = \"Create Headers\"\n    description = \"Creates a headers dictionary with a dynamic Authorization header.\"\n    icon = \"custom_components\"\n    name = \"CreateHeaders\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"input_value\",\n            display_name=\"Authorization Token\",\n            info=\"Enter the token to be used in the Authorization header.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Output\", name=\"output\", method=\"build_output\"),\n    ]\n\n    def build_output(self) -> Data:\n        authorization_header = f\"Bearer {self.input_value}\"\n        headers = {\n            \"Authorization\": authorization_header,\n            \"Content-Type\": \"application/json\",\n        }\n\n        data = Data(value=headers)\n        self.status = data\n        return headers\n        \n        ","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false,"display_name":"code","proxy":{"id":"CreateHeaders-Z9MyP","field":"code"}},"input_value_CreateHeaders-JXbj1":{"trace_as_input":true,"trace_as_metadata":true,"load_from_db":true,"list":false,"required":false,"placeholder":"","show":true,"name":"input_value","value":"BIGQUERY_API_KEY","display_name":"Authorization Token","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Enter the token to be used in the Authorization header.","title_case":false,"type":"str","_input_type":"MessageTextInput","proxy":{"id":"CreateHeaders-Z9MyP","field":"input_value"}}},"flow":{"data":{"nodes":[{"id":"APIRequest-PVjtY","type":"genericNode","position":{"x":-997.3826700598629,"y":-861.3323833961656},"data":{"type":"APIRequest","node":{"template":{"_type":"Component","query_params":{"trace_as_input":true,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"value":"","name":"query_params","display_name":"Query Parameters","advanced":false,"input_types":["Data"],"dynamic":false,"info":"The query parameters to append to the URL.","title_case":false,"type":"other","_input_type":"DataInput"},"body":{"trace_as_input":true,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"value":{},"name":"body","display_name":"Body","advanced":false,"input_types":["Data"],"dynamic":false,"info":"The body to send with the request as a dictionary (for POST, PATCH, PUT). This is populated when using the CURL field.","title_case":false,"type":"NestedDict","_input_type":"NestedDictInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import asyncio\nimport json\nfrom typing import Any, List, Optional\nfrom urllib.parse import parse_qsl, urlencode, urlparse, urlunparse\n\nimport httpx\nfrom loguru import logger\n\nfrom langflow.base.curl.parse import parse_context\nfrom langflow.custom import Component\nfrom langflow.io import DataInput, DropdownInput, IntInput, MessageTextInput, NestedDictInput, Output\nfrom langflow.schema import Data\nfrom langflow.schema.dotdict import dotdict\n\n\nclass APIRequestComponent(Component):\n    display_name = \"API Request\"\n    description = (\n        \"This component allows you to make HTTP requests to one or more URLs. \"\n        \"You can provide headers and body as either dictionaries or Data objects. \"\n        \"Additionally, you can append query parameters to the URLs.\\n\\n\"\n        \"**Note:** Check advanced options for more settings.\"\n    )\n    icon = \"Globe\"\n    name = \"APIRequest\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"urls\",\n            display_name=\"URLs\",\n            is_list=True,\n            info=\"Enter one or more URLs, separated by commas.\",\n        ),\n        MessageTextInput(\n            name=\"curl\",\n            display_name=\"Curl\",\n            info=\"Paste a curl command to populate the fields. This will fill in the dictionary fields for headers and body.\",\n            advanced=False,\n            refresh_button=True,\n        ),\n        DropdownInput(\n            name=\"method\",\n            display_name=\"Method\",\n            options=[\"GET\", \"POST\", \"PATCH\", \"PUT\"],\n            value=\"GET\",\n            info=\"The HTTP method to use (GET, POST, PATCH, PUT).\",\n        ),\n        NestedDictInput(\n            name=\"headers\",\n            display_name=\"Headers\",\n            info=\"The headers to send with the request as a dictionary. This is populated when using the CURL field.\",\n            input_types=[\"Data\"],\n        ),\n        NestedDictInput(\n            name=\"body\",\n            display_name=\"Body\",\n            info=\"The body to send with the request as a dictionary (for POST, PATCH, PUT). This is populated when using the CURL field.\",\n            input_types=[\"Data\"],\n        ),\n        DataInput(\n            name=\"query_params\",\n            display_name=\"Query Parameters\",\n            info=\"The query parameters to append to the URL.\",\n        ),\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Timeout\",\n            value=5,\n            info=\"The timeout to use for the request.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"make_requests\"),\n    ]\n\n    def parse_curl(self, curl: str, build_config: dotdict) -> dotdict:\n        try:\n            parsed = parse_context(curl)\n            build_config[\"urls\"][\"value\"] = [parsed.url]\n            build_config[\"method\"][\"value\"] = parsed.method.upper()\n            build_config[\"headers\"][\"value\"] = dict(parsed.headers)\n\n            if parsed.data:\n                try:\n                    json_data = json.loads(parsed.data)\n                    build_config[\"body\"][\"value\"] = json_data\n                except json.JSONDecodeError as e:\n                    logger.error(f\"Error decoding JSON data: {e}\")\n            else:\n                build_config[\"body\"][\"value\"] = {}\n        except Exception as exc:\n            logger.error(f\"Error parsing curl: {exc}\")\n            raise ValueError(f\"Error parsing curl: {exc}\")\n        return build_config\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name == \"curl\" and field_value:\n            build_config = self.parse_curl(field_value, build_config)\n        return build_config\n\n    async def make_request(\n        self,\n        client: httpx.AsyncClient,\n        method: str,\n        url: str,\n        headers: Optional[dict] = None,\n        body: Optional[dict] = None,\n        timeout: int = 5,\n    ) -> Data:\n        method = method.upper()\n        if method not in [\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\"]:\n            raise ValueError(f\"Unsupported method: {method}\")\n\n        if isinstance(body, str) and body:\n            try:\n                body = json.loads(body)\n            except Exception as e:\n                logger.error(f\"Error decoding JSON data: {e}\")\n                body = None\n                raise ValueError(f\"Error decoding JSON data: {e}\")\n\n        data = body if body else None\n\n        try:\n            response = await client.request(method, url, headers=headers, json=data, timeout=timeout)\n            try:\n                result = response.json()\n            except Exception:\n                result = response.text\n            return Data(\n                data={\n                    \"source\": url,\n                    \"headers\": headers,\n                    \"status_code\": response.status_code,\n                    \"result\": result,\n                },\n            )\n        except httpx.TimeoutException:\n            return Data(\n                data={\n                    \"source\": url,\n                    \"headers\": headers,\n                    \"status_code\": 408,\n                    \"error\": \"Request timed out\",\n                },\n            )\n        except Exception as exc:\n            return Data(\n                data={\n                    \"source\": url,\n                    \"headers\": headers,\n                    \"status_code\": 500,\n                    \"error\": str(exc),\n                },\n            )\n\n    def add_query_params(self, url: str, params: dict) -> str:\n        url_parts = list(urlparse(url))\n        query = dict(parse_qsl(url_parts[4]))\n        query.update(params)\n        url_parts[4] = urlencode(query)\n        return urlunparse(url_parts)\n\n    async def make_requests(self) -> List[Data]:\n        method = self.method\n        urls = [url.strip() for url in self.urls if url.strip()]\n        curl = self.curl\n        headers = self.headers or {}\n        body = self.body or {}\n        timeout = self.timeout\n        query_params = self.query_params.data if self.query_params else {}\n\n        if curl:\n            self._build_config = self.parse_curl(curl, dotdict())\n\n        if isinstance(headers, Data):\n            headers = headers.data\n\n        if isinstance(body, Data):\n            body = body.data\n\n        bodies = [body] * len(urls)\n\n        urls = [self.add_query_params(url, query_params) for url in urls]\n\n        async with httpx.AsyncClient() as client:\n            results = await asyncio.gather(\n                *[self.make_request(client, method, u, headers, rec, timeout) for u, rec in zip(urls, bodies)]\n            )\n        self.status = results\n        return results\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false,"display_name":"code"},"curl":{"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"value":"","name":"curl","display_name":"Curl","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Paste a curl command to populate the fields. This will fill in the dictionary fields for headers and body.","refresh_button":true,"title_case":false,"type":"str","_input_type":"MessageTextInput"},"headers":{"trace_as_input":true,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"value":{},"name":"headers","display_name":"Headers","advanced":false,"input_types":["Data"],"dynamic":false,"info":"The headers to send with the request as a dictionary. This is populated when using the CURL field.","title_case":false,"type":"NestedDict","_input_type":"NestedDictInput"},"method":{"trace_as_metadata":true,"options":["GET","POST","PATCH","PUT"],"combobox":false,"required":false,"placeholder":"","show":true,"value":"POST","name":"method","display_name":"Method","advanced":false,"dynamic":false,"info":"The HTTP method to use (GET, POST, PATCH, PUT).","title_case":false,"type":"str","_input_type":"DropdownInput"},"timeout":{"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"value":"5","name":"timeout","display_name":"Timeout","advanced":false,"dynamic":false,"info":"The timeout to use for the request.","title_case":false,"type":"int","_input_type":"IntInput"},"urls":{"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":true,"required":false,"placeholder":"","show":true,"value":["https://bigquery.googleapis.com/bigquery/v2/projects/spherical-proxy-424916-c9/queries"],"name":"urls","display_name":"URLs","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Enter one or more URLs, separated by commas.","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"This component allows you to make HTTP requests to one or more URLs. You can provide headers and body as either dictionaries or Data objects. Additionally, you can append query parameters to the URLs.\n\n**Note:** Check advanced options for more settings.","icon":"Globe","base_classes":["Data"],"display_name":"API Request","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"data","display_name":"Data","method":"make_requests","value":"__UNDEFINED__","cache":true,"hidden":false}],"field_order":["urls","curl","method","headers","body","query_params","timeout"],"beta":false,"edited":false,"lf_version":"1.0.17"},"id":"APIRequest-PVjtY"},"selected":true,"width":384,"height":986,"positionAbsolute":{"x":-997.3826700598629,"y":-861.3323833961656},"dragging":false},{"id":"CustomComponent-AybY7","type":"genericNode","position":{"x":-1413.1760103792083,"y":-254.49207932765808},"data":{"type":"CustomComponent","node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"# from langflow.field_typing import Data\nfrom langflow.custom import Component\nfrom langflow.io import MessageTextInput, Output\nfrom langflow.schema import Data\nimport re  # Import regex module\n\nclass CustomComponent(Component):\n    display_name = \"Format Body\"\n    description = \"Turn OpenAI SQL output into a body to send with a fetch.\"\n    documentation: str = \"http://docs.langflow.org/components/custom\"\n    icon = \"custom_components\"\n    name = \"CustomComponent\"\n\n    inputs = [\n        MessageTextInput(name=\"input_value\", display_name=\"Input Value\", value=\"```sql\\nbigquery-public-data.ga4_obfuscated_sample_ecommerce.events_*\\n```\"),\n    ]\n\n    outputs = [\n        Output(display_name=\"Output\", name=\"output\", method=\"build_output\"),\n    ]\n\n    def build_output(self) -> Data:\n        # Remove the surrounding markdown and any trailing newline\n        input_value_cleaned = re.sub(r\"^```sql\\n|```$\", \"\", self.input_value.strip()).strip()\n\n        # Format the cleaned SQL string into the desired object\n        formatted_data = {\n            \"query\": input_value_cleaned,\n            \"maxResults\": 20,\n            \"timeoutMs\": 10000,\n            \"useLegacySql\": False\n        }\n        \n        # Return the formatted data as the output\n        data = Data(value=formatted_data)\n        self.status = data\n        \n        # Print the formatted data to the chat (for debugging purposes)\n        print(f\"Output Data: {formatted_data}\")\n        \n        return formatted_data\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false,"display_name":"code"},"input_value":{"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"input_value","value":"","display_name":"Input Value","advanced":false,"input_types":["Message"],"dynamic":false,"info":"","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Turn OpenAI SQL output into a body to send with a fetch.","icon":"custom_components","base_classes":["Data"],"display_name":"Custom Component","documentation":"http://docs.langflow.org/components/custom","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"output","display_name":"Output","method":"build_output","value":"__UNDEFINED__","cache":true}],"field_order":["input_value"],"beta":false,"edited":true,"lf_version":"1.0.17"},"id":"CustomComponent-AybY7"},"selected":true,"width":384,"height":326,"dragging":false,"positionAbsolute":{"x":-1413.1760103792083,"y":-254.49207932765808}},{"id":"FetchProcessorComponent-cAiH1","type":"genericNode","position":{"x":-507.4467437912496,"y":-179.714631883013},"data":{"type":"FetchProcessorComponent","node":{"template":{"_type":"Component","fetch_response":{"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"fetch_response","value":"","display_name":"Fetch Response","advanced":false,"input_types":["Data"],"dynamic":false,"info":"","title_case":false,"type":"other","_input_type":"HandleInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from langflow.custom import Component\nfrom langflow.io import MessageTextInput, Output\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\nimport json\n\n\nclass FetchProcessorComponent(Component):\n    display_name = \"Fetch Processor\"\n    description = \"Process fetch output, print it, and stringify it for chat.\"\n    documentation: str = \"http://docs.langflow.org/components/custom\"\n    icon = \"custom_components\"\n    name = \"FetchProcessorComponent\"\n\n    inputs = [\n        HandleInput(\n            name=\"fetch_response\",\n            display_name=\"Fetch Response\",\n            input_types=[\"Data\"],\n        )\n    ]\n\n    outputs = [\n        Output(display_name=\"Processed Output\", name=\"processed_output\", method=\"process_output\"),\n    ]\n    \n    def process_output(self) -> Message:\n        try:\n            # Directly use the fetch_response as the input data\n            response_data = self.fetch_response\n\n            # Extract the response content\n            content = str(response_data[0].data[\"result\"])\n            \n            # Truncate the content to a specific length (e.g., 5000 characters)\n            max_length = 5000\n            truncated_content = content[:max_length]\n            \n            # Convert the truncated content to a string that can be printed\n            output_str = \"Processed Output: \" + str(truncated_content)+\"...\"\n            \n            \n            # Return the processed string as a Message\n            self.status = output_str\n            return Message(text=output_str)\n\n        except Exception as e:\n            # Handle any errors and print them\n            error_message = f\"Error processing fetch response: {str(e)}\"\n            print(error_message)\n            return Message(text=error_message)\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false,"display_name":"code"}},"description":"Process fetch output, print it, and stringify it for chat.","icon":"custom_components","base_classes":["Message"],"display_name":"Custom Component","documentation":"http://docs.langflow.org/components/custom","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"processed_output","display_name":"Processed Output","method":"process_output","value":"__UNDEFINED__","cache":true}],"field_order":["fetch_response"],"beta":false,"edited":true,"lf_version":"1.0.17"},"id":"FetchProcessorComponent-cAiH1"},"selected":true,"width":384,"height":290,"dragging":false,"positionAbsolute":{"x":-507.4467437912496,"y":-179.714631883013}},{"id":"CreateHeaders-Z9MyP","type":"genericNode","position":{"x":-1396.7706525601332,"y":-769.2408023743359},"data":{"type":"CreateHeaders","node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from langflow.custom import Component\nfrom langflow.inputs import MessageTextInput\nfrom langflow.template import Output\nfrom pydantic.v1 import SecretStr\nfrom langflow.schema import Data\n\n\n\nclass CreateHeadersComponent(Component):\n    display_name = \"Create Headers\"\n    description = \"Creates a headers dictionary with a dynamic Authorization header.\"\n    icon = \"custom_components\"\n    name = \"CreateHeaders\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"input_value\",\n            display_name=\"Authorization Token\",\n            info=\"Enter the token to be used in the Authorization header.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Output\", name=\"output\", method=\"build_output\"),\n    ]\n\n    def build_output(self) -> Data:\n        authorization_header = f\"Bearer {self.input_value}\"\n        headers = {\n            \"Authorization\": authorization_header,\n            \"Content-Type\": \"application/json\",\n        }\n\n        data = Data(value=headers)\n        self.status = data\n        return headers\n        \n        ","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false,"display_name":"code"},"input_value":{"trace_as_input":true,"trace_as_metadata":true,"load_from_db":true,"list":false,"required":false,"placeholder":"","show":true,"name":"input_value","value":"BIGQUERY_API_KEY","display_name":"Authorization Token","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Enter the token to be used in the Authorization header.","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Creates a headers dictionary with a dynamic Authorization header.","icon":"custom_components","base_classes":["Data"],"display_name":"Create List","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"output","display_name":"Output","method":"build_output","value":"__UNDEFINED__","cache":true}],"field_order":["input_value"],"beta":false,"edited":true,"lf_version":"1.0.17"},"id":"CreateHeaders-Z9MyP"},"selected":true,"width":384,"height":326,"positionAbsolute":{"x":-1396.7706525601332,"y":-769.2408023743359},"dragging":false}],"edges":[{"source":"APIRequest-PVjtY","sourceHandle":"{œdataTypeœ:œAPIRequestœ,œidœ:œAPIRequest-PVjtYœ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}","target":"FetchProcessorComponent-cAiH1","targetHandle":"{œfieldNameœ:œfetch_responseœ,œidœ:œFetchProcessorComponent-cAiH1œ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","data":{"targetHandle":{"fieldName":"fetch_response","id":"FetchProcessorComponent-cAiH1","inputTypes":["Data"],"type":"other"},"sourceHandle":{"dataType":"APIRequest","id":"APIRequest-PVjtY","name":"data","output_types":["Data"]}},"id":"reactflow__edge-APIRequest-PVjtY{œdataTypeœ:œAPIRequestœ,œidœ:œAPIRequest-PVjtYœ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}-FetchProcessorComponent-cAiH1{œfieldNameœ:œfetch_responseœ,œidœ:œFetchProcessorComponent-cAiH1œ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","className":"","selected":true},{"source":"CustomComponent-AybY7","sourceHandle":"{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-AybY7œ,œnameœ:œoutputœ,œoutput_typesœ:[œDataœ]}","target":"APIRequest-PVjtY","targetHandle":"{œfieldNameœ:œbodyœ,œidœ:œAPIRequest-PVjtYœ,œinputTypesœ:[œDataœ],œtypeœ:œNestedDictœ}","data":{"targetHandle":{"fieldName":"body","id":"APIRequest-PVjtY","inputTypes":["Data"],"type":"NestedDict"},"sourceHandle":{"dataType":"CustomComponent","id":"CustomComponent-AybY7","name":"output","output_types":["Data"]}},"id":"reactflow__edge-CustomComponent-AybY7{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-AybY7œ,œnameœ:œoutputœ,œoutput_typesœ:[œDataœ]}-APIRequest-PVjtY{œfieldNameœ:œbodyœ,œidœ:œAPIRequest-PVjtYœ,œinputTypesœ:[œDataœ],œtypeœ:œNestedDictœ}","className":"","selected":true},{"source":"CreateHeaders-Z9MyP","sourceHandle":"{œdataTypeœ:œCreateHeadersœ,œidœ:œCreateHeaders-Z9MyPœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataœ]}","target":"APIRequest-PVjtY","targetHandle":"{œfieldNameœ:œheadersœ,œidœ:œAPIRequest-PVjtYœ,œinputTypesœ:[œDataœ],œtypeœ:œNestedDictœ}","data":{"targetHandle":{"fieldName":"headers","id":"APIRequest-PVjtY","inputTypes":["Data"],"type":"NestedDict"},"sourceHandle":{"dataType":"CreateHeaders","id":"CreateHeaders-Z9MyP","name":"output","output_types":["Data"]}},"id":"reactflow__edge-CreateHeaders-Z9MyP{œdataTypeœ:œCreateHeadersœ,œidœ:œCreateHeaders-Z9MyPœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataœ]}-APIRequest-PVjtY{œfieldNameœ:œheadersœ,œidœ:œAPIRequest-PVjtYœ,œinputTypesœ:[œDataœ],œtypeœ:œNestedDictœ}","selected":true,"className":""}],"viewport":{"zoom":1,"x":0,"y":0}},"is_component":false,"name":"Zany Carson","description":"","id":"6QNKt"},"outputs":[{"types":["Message"],"selected":"Message","name":"FetchProcessorComponent-p3ylx_processed_output","display_name":"Processed Output","method":"process_output","value":"__UNDEFINED__","cache":true,"proxy":{"id":"FetchProcessorComponent-cAiH1","name":"processed_output","nodeDisplayName":"Custom Component"}}],"official":false}},"id":"GroupNode-zAmwl","position":{"x":0,"y":0},"type":"genericNode"}],"viewport":{"x":1,"y":1,"zoom":1}},"user_id":"027760a5-eeff-4518-a6d4-42fbacd6beeb","folder_id":"988bb63d-5695-4fb3-a60a-3290e88cd510"}